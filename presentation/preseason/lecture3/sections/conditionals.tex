\documentclass[../lecture3-flowofcontrol.tex]{subfiles}

\begin{document}

\section{Conditionals}

% -------------------------------------------------------------------

\begin{frame}[fragile]{Conditionals}
    In order for a program to change its behavior depending on the input, there must be a way to test that input. Conditionals allow the program to check the values of variables and to execute (or not execute) certain statements. \newline

    C++ has \texttt{if} and \texttt{switch-case} conditional structures.
\end{frame}

% -------------------------------------------------------------------

\begin{frame}[fragile]{Operators}
    Conditionals use two kinds of special operators: \texttt{relational} and \texttt{logical}. These are used to determine whether some condtion is true or false.
\end{frame}

\begin{frame}[fragile]{Relational Operators}
    Relational operators are used to test a relation between two expressions:

    \begin{table}
        \center
        \begin{tabular}{c|c|c}
            \toprule
            \textbf{Operator} & \textbf{Shorthand} & \textbf{Meaning} \\
            \midrule
            \verb|>|  &       & Greater than \\
            \verb|>=| & $\ge$ & Greater than or equal to \\
            \verb|<|  &       & Less than \\
            \verb|<=| & $\le$ & Less than or equal to \\
            \verb|==| &       & Equal to \\
            \verb|!=| & $\ne$ & Not equal to \\
            \bottomrule
        \end{tabular}
    \end{table}

    They work the same as the arithmetic operators (e.g. \verb|a > b|) but return a Boolean value of either \texttt{true} or \texttt{false}, indicating whether the relation tested for holds (Boolean expression). \newline

    For example, if the variables \verb|x| and \verb|y| have been set to 6 and 2, respectively, then \verb|x > y| returns \texttt{true}. Similarly, \verb|x < 5| returns \texttt{false}.
\end{frame}

\begin{frame}[fragile]{Logical Operators}
    The logical operators are often used to combine relational expressions into more complicated Boolean expressions. \newline

    \begin{table}
        \center
        \begin{tabular}{c|c}
            \toprule
            \textbf{Operator} & \textbf{Meaning} \\
            \midrule
            \verb|&&| & and \\
            \verb+||+ & or \\
            \verb|!|  & not \\
            \bottomrule
        \end{tabular}
    \end{table}
\end{frame}

\begin{frame}[fragile]{Truth Tables}
    Operators return \texttt{true} or \texttt{false}, according to the rules of logic:

    \begin{columns}[T,onlytextwidth]
        \column{.2\textwidth}
            \begin{table}
                \begin{tabular}{c|c|c}
                    \toprule
                    \textbf{a} & \textbf{b} & \bfseries{a \verb|&&| b} \\
                    \midrule
                    true  & true  & true  \\
                    true  & false & false \\
                    false & true  & false \\
                    false & false & false \\
                    \bottomrule
                \end{tabular}
            \end{table}
        \column{.2\textwidth}
            \begin{table}
                \begin{tabular}{c|c|c}
                    \toprule
                    \textbf{a} & \textbf{b} & \bfseries{a \verb+||+ b} \\
                    \midrule
                    true  & true  & true  \\
                    true  & false & true  \\
                    false & true  & true  \\
                    false & false & false \\
                    \bottomrule
                \end{tabular}
            \end{table}
        \column{.2\textwidth}
            \begin{table}
                \begin{tabular}{c|c}
                    \toprule
                    \textbf{a} & \bfseries{\verb|!|a} \\
                    \midrule
                    true  & false \\
                    false & true  \\
                    \bottomrule
                \end{tabular}
            \end{table}
    \end{columns}

    \begin{center}
        Example questions using logical operators (assume \verb|x = 6| and \verb|y = 2|):
    \end{center}

    \begin{table}
        \center
        \begin{tabular}{cr}
            \verb|!(x > 2)|           & \pause false \\
            \pause \verb|(x > y) && (y > 0)| & \pause true  \\
            \pause \verb|(x < y) && (y > 0)| & \pause false \\
            \pause \verb+(x < y) || (y > 0)+ & \pause true  \\
        \end{tabular}
    \end{table}
\end{frame}

\begin{frame}[fragile]{C++ Boolean}
    Boolean variables can be used directly in these expressions, since they hold \verb|true| and \verb|false| values. \newline

    Funny enough, any kind of value can be used in a Boolean expression due to a quirk C++ has:
    \begin{center}
        \verb|false| is represented by a value of 0 and anything that is not 0 is \verb|true|. \newline
    \end{center}

    So, “Hello, world!” is \verb|true|, 2 is \verb|true|, and any int variable holding a non-zero value is \verb|true|. This means \verb|!x| returns \verb|false| and \verb|x && y| returns \verb|true|!
\end{frame}

% -------------------------------------------------------------------

\begin{frame}[fragile]{If}
    The \verb|if| condition has the form:
\begin{cppcode}[]
if(condition)
{
    statement1
    statement2
    ...
}
\end{cppcode}

    The condition is some expression whose value is being tested. If the condition resolves to a value of \texttt{true}, then the statements are executed before the program continues on. Otherwise, the statements are ignored. \newline

    If there is only one statement, the curly braces may be omitted, giving the form:

\begin{cppcode}[]
if(condition)
    statement
\end{cppcode}
\end{frame}

\begin{frame}[fragile]{If-Else}
    The \verb|if-else| form is used to decide between two sequences of statements referred to as \texttt{blocks}:
\begin{cppcode}[]
if(condition)
{
    statementA1
    statementA2
    ...
}
else
{
    statementB1
    statementB2
    ...
}
\end{cppcode}

    If the condition is met, the block corresponding to the \mintinline[bgcolor=black!03]{cpp}|if| is executed. Otherwise, the block corresponding to the \mintinline[bgcolor=black!03]{cpp}|else| is executed. \newline

    If there is only one statement for any of the blocks, the curly bracers for that black may be omitted:
\begin{cppcode}[]
if(condition)
    statementA1
else
    statementB1
\end{cppcode}
\end{frame}

\begin{frame}[fragile]{Else-If}
    The \verb|else if| is used to decide between two or more blocks based on \verb|multiple| conditions:
\begin{cppcode}[]
if(condition1)
{
    statement1
    statement2
    ...
}
else if(condition2)
{
    statementB1
    statementB2
    ...
}
\end{cppcode}

    If \texttt{condition1} is met, the block corresponding to the \mintinline[bgcolor=black!03]{cpp}|if| is executed. If not, then only if \texttt{condition2} is met is the block corresponding to the \mintinline[bgcolor=black!03]{cpp}|else if| executed.
\end{frame}

\begin{frame}[fragile]{If Example}
    Here is an example using these control structures:
\begin{cppcode}[]
#include <iostream>
using namespace std;

int main()
{
    int x = 6;
    int y = 2;

    if(x > y)
        cout << "x is greater than y" << endl;
    else if(y > x)
        cout << "y is greater than x" << endl;
    else
        cout << "x and y are equal" << endl;

    return 0;
}
\end{cppcode}

    The output of this program is \verb|x is greater than y|. If we set the lines 6 and 7 to \mintinline{cpp}|int x = 2;| and \mintinline{cpp}|int y = 6;| respectively, then the output is \verb|y is greater than x|. \newline

    If we replace the lines with \mintinline{cpp}|int x = 2| and \mintinline{cpp}|int y = 2;| then the output is \verb|x and y are equal|.
\end{frame}

% -------------------------------------------------------------------

\begin{frame}[fragile]{Switch-Case}
    The \verb|switch-case| is another conditional structure that may or may not execute certain statements.
    % However, the \verb|switch-case| has peculiar syntax and behavior:

\begin{cppcode}[]
switch(expression)
{
    case constant1:
            statementA1
            ...
            break;
    case constant2:
            statementB1
            ...
            break;
    ...
    default:
            statementZ1
            ...
}
\end{cppcode}
    \begin{multicols}{2}
        The \texttt{switch} evaluates \texttt{expression} and, if \texttt{expression} is equal to \texttt{constant1}, then the statements beneath \texttt{case constant 1:} are executed until a \texttt{break} is encountered. If \texttt{expression} is not equal to \texttt{constant1}, then it is compared to \texttt{constant2}. If these are equal, then the statements beneath \texttt{case constant 2:} are executed until a break is encountered. If not, then the same process repeats for each of the constants, in turn. If none of the constants match, then the statements beneath \texttt{default:} are executed.
    \end{multicols}
\end{frame}

\begin{frame}[fragile]{Switch-Case}
    Due to the peculiar behavior of switch-cases, curly braces are not necessary for cases where there is more than one statement (but they are necessary to enclose the entire switch-case). \newline \newline

    Switch-cases generally have if-else equivalents but can often be a cleaner way of expressing the same behavior.
\end{frame}

\begin{frame}[fragile]{Switch-Case Example}
    Here is an example using \verb|switch-case|:
\begin{cppcode}[]
#include <iostream>
using namespace std;

int main()
{
    int x = 6;

    switch(x)
    {
        case 1:
            cout << "x is 1" << endl;
            break;
        case 2:
        case 3:
            cout << " x is 2 or 3" << endl;
            break;
        default:
            cout << "x is not 1, 2, or 3" << endl;
    }

    return 0;
}
\end{cppcode}

    This program will print \verb|x is not 1, 2, or 3|. If we replace line 6 with \mintinline{cpp}|int x = 2;|
\end{frame}

% -------------------------------------------------------------------

\end{document}

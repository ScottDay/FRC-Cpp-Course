\documentclass[../lecture3-flowofcontrol.tex]{subfiles}

\begin{document}

\section{Conditionals}

% -------------------------------------------------------------------

\begin{frame}[fragile]{Conditionals}
t
\end{frame}

% -------------------------------------------------------------------

\begin{frame}[fragile]{Operators}
t
\end{frame}

\begin{frame}[fragile]{Relational Operators}
    \begin{table}
        \center
        \begin{tabular}{c|c|c}
            \toprule
            \textbf{Operator} & \textbf{Shorthand} & \textbf{Meaning} \\
            \midrule
            \verb|>|  &       & Greater than \\
            \verb|>=| & $\ge$ & Greater than or equal to \\
            \verb|<|  &       & Less than \\
            \verb|<=| & $\le$ & Less than or equal to \\
            \verb|==| &       & Equal to \\
            \verb|!=| & $\ne$ & Not equal to \\
            \bottomrule
        \end{tabular}
    \end{table}
\end{frame}

\begin{frame}[fragile]{Logical Operators}
    \begin{table}
        \center
        \begin{tabular}{c|c}
            \toprule
            \textbf{Operator} & \textbf{Meaning} \\
            \midrule
            \verb|&&| & and \\
            \verb+||+ & or \\
            \verb|!|  & not \\
            \bottomrule
        \end{tabular}
    \end{table}
\end{frame}

\begin{frame}[fragile]{Truth Tables}
    Operators return \verb|true| or \verb|false|, according to the rules of logic:

    \begin{columns}[T,onlytextwidth]
        \column{.2\textwidth}
            \begin{table}
                \begin{tabular}{c|c|c}
                    \toprule
                    \textbf{a} & \textbf{b} & \bfseries{a \verb|&&| b} \\
                    \midrule
                    true  & true  & true  \\
                    true  & false & false \\
                    false & true  & false \\
                    false & false & false \\
                    \bottomrule
                \end{tabular}
            \end{table}
        \column{.2\textwidth}
            \begin{table}
                \begin{tabular}{c|c|c}
                    \toprule
                    \textbf{a} & \textbf{b} & \bfseries{a \verb+||+ b} \\
                    \midrule
                    true  & true  & true  \\
                    true  & false & true  \\
                    false & true  & true  \\
                    false & false & false \\
                    \bottomrule
                \end{tabular}
            \end{table}
        \column{.2\textwidth}
            \begin{table}
                \begin{tabular}{c|c}
                    \toprule
                    \textbf{a} & \bfseries{\verb|!|a} \\
                    \midrule
                    true  & false \\
                    false & true  \\
                    \bottomrule
                \end{tabular}
            \end{table}
    \end{columns}

    \begin{center}
        Examples using logical operators (assume \verb|x = 6| and \verb|y = 2|):
    \end{center}

    \begin{table}
        \center
        \begin{tabular}{cr}
            \pause \verb|!(x > 2)|           & \pause false \\
            \pause \verb|(x > y) && (y > 0)| & \pause true  \\
            \pause \verb|(x < y) && (y > 0)| & \pause false \\
            \pause \verb+(x < y) || (y > 0)+ & \pause true  \\
        \end{tabular}
    \end{table}
\end{frame}

\begin{frame}[fragile]{C++ Boolean}
    Boolean variables can be used directly in these expressions, since they hold \verb|true| and \verb|false| values. \newline

    Funny enough, any kind of value can be used in a Boolean expression due to a quirk C++ has:
    \begin{center}
        \verb|false| is represented by a value of 0 and anything that is not 0 is \verb|true|. \newline
    \end{center}

    So, “Hello, world!” is \verb|true|, 2 is \verb|true|, and any int variable holding a non-zero value is \verb|true|. This means \verb|!x| returns \verb|false| and \verb|x && y| returns \verb|true|!
\end{frame}

% -------------------------------------------------------------------

\begin{frame}[fragile]{If}
    The \verb|if| condition has the form:
\begin{cppcode}[]
if(condition)
{
    statement1
    statement2
    ...
}
\end{cppcode}

\begin{cppcode}[]
if(condition)
    statement
\end{cppcode}
\end{frame}

\begin{frame}[fragile]{If-Else}
    The \verb|if-else| form is used to decide between two sequences of statements referred to as \verb|blocks|:
\begin{cppcode}[]
if(condition)
{
    statementA1
    statementA2
    ...
}
else
{
    statementB1
    statementB2
    ...
}
\end{cppcode}

\begin{cppcode}[]
if(condition)
    statementA1
else
    statementB1
\end{cppcode}
\end{frame}

\begin{frame}[fragile]{Else-If}
    The \verb|else if| is used to decide between two or more blocks based on \verb|multiple| conditions:
\begin{cppcode}[]
if(condition1)
{
    statement1
    statement2
    ...
}
else if(condition2)
{
    statementB1
    statementB2
    ...
}
\end{cppcode}
\end{frame}

\begin{frame}[fragile]{If Example}
    Here is an example using these control structures:
\begin{cppcode}[]
#include <iostream>
using namespace std;

int main()
{
    int x = 6;
    int y = 2;

    if(x > y)
        cout << "x is greater than y" << endl;
    else if(y > x)
        cout << "y is greater than x" << endl;
    else
        cout << "x and y are equal" << endl;

    return 0;
}
\end{cppcode}

    The output of this program is \verb|x is greater than y|. If we set the lines 6 and 7 to \mintinline{cpp}|int x = 2;| and \mintinline{cpp}|int y = 6;| respectively, then the output is \verb|y is greater than x|. \newline

    If we replace the lines with \mintinline{cpp}|int x = 2| and \mintinline{cpp}|int y = 2;| then the output is \verb|x and y are equal|.
\end{frame}

% -------------------------------------------------------------------

\begin{frame}[fragile]{Switch-Case}
    The \verb|switch-case| is another conditional structure that may or may not execute certain statements.
    % However, the \verb|switch-case| has peculiar syntax and behavior:

\begin{cppcode}[]
switch(expression)
{
    case constant1:
            statementA1
            ...
            break;
    case constant2:
            statementB1
            ...
            break;
    ...
    default:
            statementZ1
            ...
}
\end{cppcode}
    \begin{multicols}{2}
        The \texttt{switch} evaluates \texttt{expression} and, if \texttt{expression} is equal to \texttt{constant1}, then the statements beneath \texttt{case constant 1:} are executed until a \texttt{break} is encountered. If \texttt{expression} is not equal to \texttt{constant1}, then it is compared to \texttt{constant2}. If these are equal, then the statements beneath \texttt{case constant 2:} are executed until a break is encountered. If not, then the same process repeats for each of the constants, in turn. If none of the constants match, then the statements beneath \texttt{default:} are executed.
    \end{multicols}
\end{frame}

\begin{frame}[fragile]{Switch-Case}
    Due to the peculiar behavior of switch-cases, curly braces are not necessary for cases where there is more than one statement (but they are necessary to enclose the entire switch-case). \newline \newline

    Switch-cases generally have if-else equivalents but can often be a cleaner way of expressing the same behavior.
\end{frame}

\begin{frame}[fragile]{Switch-Case Example}
    Here is an example using \verb|switch-case|:
\begin{cppcode}[]
#include <iostream>
using namespace std;

int main()
{
    int x = 6;

    switch(x)
    {
        case 1:
            cout << "x is 1" << endl;
            break;
        case 2:
        case 3:
            cout << " x is 2 or 3" << endl;
            break;
        default:
            cout << "x is not 1, 2, or 3" << endl;
    }

    return 0;
}
\end{cppcode}

    This program will print \verb|x is not 1, 2, or 3|. If we replace line 6 with \mintinline{cpp}|int x = 2;|
\end{frame}

% -------------------------------------------------------------------

\end{document}
